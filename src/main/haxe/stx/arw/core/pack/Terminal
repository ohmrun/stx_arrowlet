package stx.arw;

typedef TerminalDef<R,E> = JobDef<R,E>;

interface TerminalApi<R,E>{
  public function future():FutureTrigger<Outcome<R,E>>;
  
  public function issue(res:Outcome<R,E>):Receiver<R,E>;
  public function value(r:R):Receiver<R,E>;
  public function error(err:E):Receiver<R,E>;

  public function defer(ft:Slot<Outcome<R,E>>):Receiver<R,E>;

  public function inner<RR,EE>(join:Outcome<RR,EE> -> Void):Terminal<RR,EE>;

  public function toTerminalApi():TerminalApi<R,E>;
}
@:forward abstract Terminal<R,E>(TerminalApi<R,E>) from TerminalApi<R,E> to TerminalApi<R,E>{
  static public var ZERO = new Terminal();
  public function new(){
    this = new TerminalBase();
  }
}
class TerminalBase<R,E> implements TerminalApi<R,E>{
  public function new(){}
  public function future():FutureTrigger<Outcome<R,E>>{
    return Future.trigger();
  }

  public inline function issue(res:Outcome<R,E>):Receiver<R,E>{
    return Receiver.lift(Job.issue(res));
  }
  public inline function value(r:R):Receiver<R,E>{
    return issue(Success(r));
  }
  public inline function error(err:E):Receiver<R,E>{
    return issue(Failure(err));
  }
  public inline function defer(ft:Slot<Outcome<R,E>>):Receiver<R,E>{
    return Receiver.lift(Job.defer(ft));
  }
  
  public inline function inner<RR,EE>(join:Outcome<RR,EE> -> Void):Terminal<RR,EE>{
    return new SubTerminal(join).toTerminalApi();
  }

  public inline function toTerminalApi():TerminalApi<R,E>{
    return this;
  }
}
class SubTerminal<R,E> implements TerminalApi<R,E>{
  public function future():FutureTrigger<Outcome<R,E>>{
    return Future.trigger();
  }
  private var join : Outcome<R,E> -> Void;
  public function new(join:Outcome<R,E>->Void){
    this.join = join;
  }
  public inline function value(r:R):Receiver<R,E>{
    return issue(Success(r));
  }
  public inline function error(err:E):Receiver<R,E>{
    return issue(Failure(err));
  }
  public inline function issue(res:Outcome<R,E>):Receiver<R,E>{
    return Receiver.lift(Job.issue(res).later(join));
  }
  public inline function defer(ft:Slot<Outcome<R,E>>):Receiver<R,E>{
    return Receiver.lift(Job.defer(ft).later(join));
  }
  public inline function inner<RR,EE>(join:Outcome<RR,EE> -> Void):Terminal<RR,EE>{
    return new SubTerminal(join).toTerminalApi();
  }
  public inline function toTerminalApi():TerminalApi<R,E>{
    return this;
  }
}
abstract Receiver<R,E>(JobDef<R,E>){
  public inline function new(self) this = self;
  static inline public function lift<R,E>(self:JobDef<R,E>):Receiver<R,E>{
    return new Receiver(self);
  }
  public inline function after(res:Work):Work{
    return res.seq(Job._.serve(this).errata(e -> e.elide()));
  }
  public inline function later(handler:Outcome<R,E>->Void):Receiver<R,E>{
    return lift(Job._.later(this,handler));
  }
  public inline function serve():Work{
    return Job._.serve(Job.lift(Coroutine._.errata(this,e -> e.elide())));
  }
} 