package stx.arw;

typedef Work = Agenda<Any>;


// @:using(stx.arw.Work.WorkLift)
// abstract Work(WorkDef) from WorkDef to WorkDef{
//   public function new(self) this = self;
//   static public function lift(self:WorkDef):Work return new Work(self);
  
//   public function prj():WorkDef return this;
//   private var self(get,never):Work;
//   private function get_self():Work return lift(this);

//   @:from static public function fromFutureWork(ft:Future<Work>):Work{
//     return lift(
//       Some(
//         __.hold(Guard(() -> ft.map(
//           (x) -> Option._.defv(x,Agenda.unit().toCoroutine().prj())))
//         )
//       )
//     );
//   }
// }
// class WorkLift{
//   static public inline function seq(self:Work,that:Work):Work{
//     return switch([self,that]){
//       case [Some(l),Some(r)]  : Some(Agenda._.seq(l,r));
//       case [None,Some(v)]     : Some(v);
//       case [Some(v),None]     : Some(v);
//       case [None,None]        : None;
//     }
//   }
//   static public inline function par(self:Work,that:Work):Work{
//     return switch([self,that]){
//       case [Some(l),Some(r)]  : Some(Agenda._.par(l,r));
//       case [None,Some(v)]     : Some(v);
//       case [Some(v),None]     : Some(v);
//       case [None,None]        : None;
//     }
//   }
//   static public inline function submit(self:Work,scheduler){
//     Option._.fold(
//       self,
//       (v) -> Agenda._.submit(v,null),
//       ()  -> {}
//     );
//   }
//   static public inline function crunch(self:Work,scheduler){
//     Option._.fold(
//       self,
//       (v) -> Agenda._.crunch(v,null),
//       ()  -> {}
//     );
//   }
// }