package stx.arw.core.head;

class Arrowlets{
  static public var _(default,null) = new stx.arw.core.body.Arrowlets();

  @:noUsing static public function unit<I>():Arrowlet<I,I> return new Unit();

  @:noUsing static public function fromRecall<A,B>(fn:A->Reactor<B>):Arrowlet<A,B>      return new RecallArrowlet(fn);

  @:noUsing static public function lift<I,O>(fn:ArrowletDef<I,O>):Arrowlet<I,O>{
    return new Arrowlet(fn);
  }
  @:noUsing static public function fromFunction<I,O>(f:I->O):Arrowlet<I,O>{
    return new Fun1Arrowlet(f);
  }
  @:noUsing static public function fromFunction2<PI,PII,R>(f):Arrowlet<Couple<PI,PII>,R>{
    return new Fun1Arrowlet(__.decouple(f));
  }
  @:noUsing static public function fromCallbackSink<I,O>(f:I->(O->Void)->Void):Arrowlet<I,O>{
    return new CallbackArrowlet(f);
  }
  @:noUsing static public function fromStrandAutomation<I,O>(f):Arrowlet<I,O>{
    return new Arrowlet(Recall.Anon((i:I,cont:O->Void) ->{
      return f(i,cont);
    }));
  }
  @:noUsing static public function fromReceiverArrowlet<I,O>(f):Arrowlet<I,O>{
    return new ReceiverArrowlet(f);
  }
  @doc("Pinches the input stage of an Arrowlet. `<I,I>` as `<I>`")
  @:noUsing static public function fromPair<I,O1,O2>(a:Arrowlet<Couple<I,I>,Couple<O1,O2>>):Arrowlet<I,Couple<O1,O2>>{
    return Arrowlets._.fan(Arrowlet.unit()).then(a);
  }
  // @:noUsing public function toState<S,A>(a:Arrowlet<S,Couple<A,S>>):State<S,A>{
  //   return new State(a);
  // }
}